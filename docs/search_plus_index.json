{"./":{"url":"./","title":"前言","keywords":"","body":"从零开始学算法 力扣常见考察的知识点大概有十几种，包括：二分，滑动窗口，双指针，链表，二叉树，字符串处理，dfs + 回溯，单调栈（单调队列），并查集，动态规划，贪心，位运算，数论（质数、约数、欧拉函数、欧几里得算法、中国剩余定理、简单博弈论等），图论（dfs、bfs、flood fill、拓扑排序、二分染色、最短路、最小生成树等）。 这本电子书 的 目的就是对上述知识点进行归纳总结，同时会列举一些习题供读者练习，希望通过阅读此书对您能够有所帮助，谢谢！ ♨️ 推荐阅读 二分 位运算 单调栈 滑动窗口 并查集 DFS和回溯 图的遍历 动态规划 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-07 17:38:32 "},"chapter/二分.html":{"url":"chapter/二分.html","title":"二分","keywords":"","body":"二分 应用场景 70%的二分都是跟单调性有关，有单调性的题目一般都可以二分。 95%的题目存在两段性的性质。一部分满足，一部分不满足。 算法思想 将区间分为左右两边（分治），判断中点，确定答案在哪一边，每次缩小一半，直到得到最终答案。 需要注意边界问题 模板 二分模板一共有两个，分别适用于不同情况。 算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 版本1 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1; 计算mid时不需要加1。 C++ 代码模板： int bsearch_1(int l, int r) { while (l > 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } 版本2 当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid; 此时为了防止死循环，计算mid时需要加1。 C++ 代码模板： int bsearch_2(int l, int r) { while (l > 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 练习题 lc33. Search in Rotated Sorted Array (medium) lc34. Find First and Last Position of Element in Sorted Array（medium） lc35. Search Insert Position (easy) lc69. Sqrt(x) (esay) lc74. Search a 2D Matrix (medium) lc153. Find Minimum in Rotated Sorted Array（medium） lc154. Find Minimum in Rotated Sorted Array II (hard) lc162. Find Peak Element（medium） lc275. H-Index II（medium） lc287. Find the Duplicate Number（medium） lc315. Count of Smaller Numbers After Self (hard) lc704. Binary Search（easy） Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/sort/排序.html":{"url":"chapter/sort/排序.html","title":"排序算法及应用","keywords":"","body":"排序算法 我们常说八大排序算法，实际上排序有非常多的算法，一般我们只需要掌握三种即可：冒泡、快排、归并 其中冒泡最简单，我们直接给出代码： 冒泡排序 function bubbleSort(nums) { for (let i = 0; i nums[j + 1]) { let tmp = nums[j] nums[j] = nums[j+1] nums[j+1] = tmp } } } return nums } 快速排序 和 归并排序 单独讲解 练习题目 lc912. 排序数组 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/sort/快排.html":{"url":"chapter/sort/快排.html","title":"快速排序","keywords":"","body":"快排 快排的思想：递归+分治 选择一个轴（pivot），下标i, j,通过不断移动下标、比较、交换，使得轴左边所有数据小于轴，右边所有数据大于轴； 递归进行上述过程，直到所有数列长度为0或1，排序结束； 由于每次迭代过程，至少有一个值（轴）排好序，所以最终算法会终止； function quickSort(nums) { function recursive(nums, i, j) { if (i >= j) return nums let pivot = partition(nums, i, j) recursive(nums, i, pivot - 1) recursive(nums, pivot + 1, j) return nums } function partition(nums, low, high) { let pivot = nums[low] while (low = pivot) high-- nums[low] = nums[high] while (low 不稳定排序，中间交换过程会打乱顺序 时间复杂度：最差O(N^2)，平均O(N^logN) 优化 随机轴元素 另一种写法(轴的位置可以随机)： 取中点为轴 找到左边第一个大于等于轴的元素A，找到右边第一个大于等于轴的元素B 当A的下标小于B的下标时，交换 递归上述过程 void quick_sort(int q[], int l, int r) { if (l >= r) return; int i = l - 1, j = r + 1, x = q[l + r >> 1]; while (i x); if (i 相关题目 取数组前K小的数 215. 数组中的第K个最大元素 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/sort/归并.html":{"url":"chapter/sort/归并.html","title":"归并排序","keywords":"","body":"归并 易于理解的写法 function mergeSort(nums) { function recursive(nums, low, high) { if (low >= high) return let mid = (low + high) >> 1 recursive(nums, low, mid) recursive(nums, mid + 1, high) merge(nums, low, mid, high) return nums } function merge(nums, low, mid, high) { let temp = [] // 存储归并结果 let i = 0; // 归并结果游标 let l = low, r = mid + 1 // 左右两边起始下标 while (l 是稳定排序 时间复杂度：O(N^logN) 另一种写法： int t[100001]; void mergesort(int a[], int l, int r){ if (l >= r) return; int mid = l+r>> 1; mergesort(a, l, mid), mergesort(a, mid+1, r); int i = l, j = mid+1, k= 0; while (i 练习题目 Acwing65. 数组中的逆序对 剑指offer51. 数组中的逆序对 lc315. Count of Smaller Numbers After Self (hard) lc148. 排序链表 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/字符串处理.html":{"url":"chapter/字符串处理.html","title":"字符串处理","keywords":"","body":"字符串处理 字符串处理题目特点 难度可能不是很高，但是需要注意细节 力扣相关题目总结 LeetCode 38. Count and Say (easy) LeetCode 49. Group Anagrams (medium) LeetCode 151. Reverse Words in a String (medium) LeetCode 165. Compare Version Numbers (medium) LeetCode 929. Unique Email Addresses (easy) LeetCode 5. Longest Palindromic Substring (medium) LeetCode 6. ZigZag Conversion LeetCode 3. Longest Substring Without Repeating Characters LeetCode 208. Implement Trie (Prefix Tree) LeetCode 273. Integer to English Words 题目答案参考algorithms目录下对应题目解析 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/DFS和回溯.html":{"url":"chapter/DFS和回溯.html","title":"DFS和回溯","keywords":"","body":"dfs & 递归 & 回溯 & 剪枝 这四种算法结合使用，可以解决几类问题 排列组合问题 棋盘搜索的问题，往往是在一个棋盘上查找最短路径、路径方案数 递归代码模板 递归即为闭包 func dfs(){ doSomeThing() dfs() doAnotherThing() } 回溯即附加条件后，递归下一状态之前，要回退上一步附加操作 func dfs(){ change() dfs() unchange() } dfs & 递归 & 回溯 & 剪枝 结合使用，代码模板 for all router { // 遍历所有路径 doCounter() // 统计结果 doCut() // 剪枝 func dfs(){ // 深搜 doSomeThing() // 搜索处理，保存当前状态等 change() // 当前棋盘变化 dfs() // 递归 unchange() // 回溯棋盘变化（恢复现场） doAnotherThing() } } 适用于解决的问题特征 深度优先搜索经常用来处理数据量非常庞大的问题 比如数独问题，用宽搜搜不完的 常用于解决树形问题 宽度优先搜索经常用来处理最短路径，或最短距离 深度搜索不一定等于递归，也可以用循环来实现 所谓回溯就是恢复初始状态（恢复现场） 如果我们的状态是整个棋盘，就需要恢复现场，如果是某一个格子，就不需要恢复现场 经典问题 引入几个简单问题，帮助大家理解概念 递归经典问题：汉诺塔 回溯经典问题：八皇后 递归经典问题：汉诺塔 三座塔A, B, C，求移动的最小次数 分三步： 把上面的n-1，从A->B; 把最下面的盘子，从A->C; 把B上的n-1，从B->A; 递归求解 function Hanoi(n){ if (n == 1) return 1 if (n == 2) return 3 return 2*Hanoi(n-1) + 1 // 可以通过递推公式得到 } 拓展： 四座塔A, B, C, D, 求移动的最小次数。 转自acwing 可以进行动态规划，递推求解 #include using namespace std; int d[21],f[21],i,j; int main() { for (i=1;i 所有递归问题都可以转化为递推求解 比如题目62.不同路径可以使用递归求路径总数，也可以用动态规划，根据状态转换方程，递推求解 我的习惯是如果方便使用递推求解，可以直接递推，如果递归更容易理解，也可以递归 递归的问题是：容易出现爆栈，而且一旦逻辑出错，定位问题的难度也要高于递推 回溯经典问题：八皇后问题 八皇后问题是讲解回溯的经典案例 参考力扣51.N皇后 练习题 排列、组合、子集相关 LeetCode 79. Word Search （medium） LeetCode 46. Permutations（medium） LeetCode 47. Permutations II（medium） LeetCode 78. Subsets（medium） 两种思路：dfs + 回溯；二进制法 LeetCode 90. Subsets II（medium） LeetCode 39. Combination Sum（medium） LeetCode 40. Combination Sum II（medium） LeetCode 216. Combination Sum III（medium） LeetCode 17. Letter Combinations of a Phone Number（medium） LeetCode 52. N-Queens II LeetCode 37. Sudoku Solver 拓展:数据结构 Dancing Links LeetCode 473. Matchsticks to Square 剪枝的经典题目,通过增加剪枝，极大优化宽搜效率 LeetCode 22. Generate Parentheses（medium） LeetCode 131. Palindrome Partitioning（medium） LeetCode 306. Additive Number（medium） LeetCode 329. Longest Increasing Path in a Matrix (hard) dp, dfs Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/单调栈.html":{"url":"chapter/单调栈.html","title":"单调栈","keywords":"","body":"单调栈 单调栈分为单调递增栈和单调递减栈 单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈 单调栈里存的是数组元素的值或下标 单调栈的意义：可以在O(N)的时间复杂度，找到两边第一个小于或大于当前元素的值； 常见模型：找出每个数左右两边离它最近（或第一个）大于或小于它的解 单调递增栈用于查找两边第一个小于当前元素的值，单调递减栈用于查找两边第一个大于当前元素的值 一般数组中的单调性问题，题目中隐含第一个或离此元素最近的大于或小于元素的值，这类问题都可以考虑下，用单调栈是否可以求解 动画演示 单调递增栈模板 stack stk; for (int i = 0; i 例题 给定一个长度为N的正整数数组，输出每个数左右两边第一个比它小的数，如果不存在则输出-1。 输入: [3,4,2,7,5] 输出： 左边：[-1, 3, -1, 2, 2] 右边：[2, 2, -1, 5, -1] 单调递增栈 出栈时，栈顶右边第一个更小的 元素是即将入栈的当前元素 入栈时，当前元素 左边的第一个更小的元素 是 栈顶元素 void sumSubarrayMins(vector &A) { int n = A.size(); vector lmin(n, -1); vector rmin(n, -1); stack stk; // 单调递增栈 for (int i = 0; i 时间复杂度O(N)，空间复杂度O(N) 拓展练习 lc907. 子数组的最小值之和 练习题目 lc42. 接雨水 lc84. 柱状图中最大的矩形 单调递增栈 lc85. 最大矩形 在84题基础上可以求解 lc239. 滑动窗口最大值 lc402. 移掉K位数字 贪心 + 单调递增栈，也是一道有趣的题目 lc503. 下一个更大元素 II 求右边大于元素的最近的元素；单调递减栈 + 循环队列 lc768. 最多能完成排序的块 II 特殊的单调递增栈，存储元素为两个边界 lc739. 每日温度 lc901. 股票价格跨度 求大于元素的左边第一个元素和右边第一个元素的跨度 lc962.最大宽度坡 单调栈求整个序列最大跨度问题 跟1124类似 1019.链表中的下一个更大节点 求大于元素的右边最近的元素 lc1124. 表现良好的最长时间段 前缀和 + 单调栈 单调栈求整个序列最大跨度问题 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/滑动窗口.html":{"url":"chapter/滑动窗口.html","title":"滑动窗口","keywords":"","body":"滑动窗口 算法思路 使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。 先不断地增加 right 指针扩大窗口 [left, right]，直到窗口符合要求 停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求。同时，每次增加 left，我们都要更新一轮结果。 重复第 2 和第 3 步，直到 right 到达尽头。 第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。 左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。 注意: 滑动窗口适用的题目一般具有单调性 滑动窗口、双指针、单调队列和单调栈经常配合使用 代码模板 int left = 0, right = 0; // 左右指针 while (right 练习题目 lc3. 无重复字符的最长子串(medium) lc209. Minimum Size Subarray Sum(medium) 求N个正整数数组中连续子数组的和大于等于s的最小长度 分析：满足单调性，可以用滑动窗口，左右指针维护窗口，定义s记录窗口元素和 lc395. 至少有K个重复字符的最长子串(medium) lc424. 替换后的最长重复字符(medium) lc904. 水果成篮(medium) lc239. 滑动窗口最大值(hard) lc76. 最小覆盖子串(hard) lc438. 找到字符串中所有字母异位词(medium) lc480. 滑动窗口中位数(hard) lc567. 字符串的排列 lc992. K个不同整数的子数组 lc995. K连续位的最小翻转次数 lc978. 最长湍流子数组 lc1040. 移动石子直到连续II lc1052. 爱生气的书店老板 lc1074. 元素和为目标值的子矩阵数量 lc1208. 尽可能使字符串相等 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/前缀和.html":{"url":"chapter/前缀和.html","title":"前缀和","keywords":"","body":"前缀和 一维前缀和 S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] 模板题 AcWing 795. 前缀和 二维前缀和 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] —— 模板题 AcWing 796. 子矩阵的和 练习题 lc560. Subarray Sum Equals K Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/链表.html":{"url":"chapter/链表.html","title":"链表","keywords":"","body":"链表 力扣上链表相关题目总结 解题技巧： 删除节点时，是否需要在开头增加辅助节点 dummpy节点 练习题目 LeetCode 19. Remove Nth Node From End of List (medium) 有可能删除头结点，所以在头节点前面增加一个dummpy节点辅助求解，返回dummpy->next作为头结点 LeetCode 237. Delete Node in a Linked List (easy) 给定的是链表节点指针，我们得不到前驱节点，所以转换思考方式，将下一个节点的值赋值给当前节点，然后删除下一个节点即可 LeetCode 83. Remove Duplicates from Sorted List (easy) 值相同时，删除后一个节点即可 LeetCode 61. Rotate List (medium) 遍历一次，记录链表节点数n，计算 k%=n, 快指针先移动k步，然后快慢指针同时移动，当快指针到达链表尾，慢指针到达倒数第k+1个节点，慢指针next为旋转后的头结点，慢指针next断开，快指针此时在尾结点的位置接到头结点，完成旋转 LeetCode 24. Swap Nodes in Pairs (medium) 对头节点有操作，需要辅助节点；反转过程，需要三个变量节点完成，cur->first->second, 依次完成first和second 的反转 LeetCode 206. Reverse Linked List (easy) 递归和非递归两种实现方式 LeetCode 92. Reverse Linked List II (medium) LeetCode 160. Intersection of Two Linked Lists LeetCode 142. Linked List Cycle II LeetCode 148. Sort List 86.分隔链表 143.重排链表 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/binary-tree/二叉树.html":{"url":"chapter/binary-tree/二叉树.html","title":"二叉树","keywords":"","body":"二叉树 二叉树是一种常见的基础数据结构，以二分叉的特点得名 二叉树节点一般包含值、左节点、右节点三个属性 学习大纲 二叉树涉及到的知识点 一般 包括： 二叉树的遍历 二叉搜索树（一种特殊的二叉树） Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/binary-tree/二叉树的遍历.html":{"url":"chapter/binary-tree/二叉树的遍历.html","title":"二叉树的遍历","keywords":"","body":"二叉树的遍历 二叉树有深度优先和广度优先两种遍历方式 其中深度优先遍历（dfs）又分为前序、中序、后序三种遍历方式 可以用递归和非递归方式实现 深度优先搜索 前序遍历 中序遍历 后序遍历 宽度优先搜索 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/binary-tree/深度优先--前序遍历.html":{"url":"chapter/binary-tree/深度优先--前序遍历.html","title":"深度优先--前序遍历","keywords":"","body":"前序遍历 遍历顺序：根左右 递归 func dfs(root){ visit(root) dfs(root.left) dfs(root.right) } 代码实现 class Solution { private: vector ans; public: vector preorderTraversal(TreeNode* root) { dfs(root); return ans; } void dfs(TreeNode* root){ if (!root) return ; ans.push_back(root->val); dfs(root->left); dfs(root->right); } }; 非递归方式 用指针p表示当前位置，用一个来栈记录访问顺序 对于每一个当前节点p，先访问p, 然后右子树入栈，然后访问左子树 栈S; p= root; while(p || S不空){ while(p){ 访问p节点； p的右子树入S; p = p的左子树; } p = S栈顶弹出; } 代码实现 class Solution { public: vector preorderTraversal(TreeNode* root) { vector ans; TreeNode* p = root; vector stk; while (p || !stk.empty()){ while (p){ ans.push_back(p->val); stk.push_back(p->right); p = p->left; } p = stk.back(); stk.pop_back(); } return ans; } }; Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/binary-tree/深度优先--中序遍历.html":{"url":"chapter/binary-tree/深度优先--中序遍历.html","title":"深度优先--中序遍历","keywords":"","body":"中序遍历 中序遍历：左根右 递归方式 func dfs(root){ dfs(root.left) visit(root) dfs(root.right) } 非递归方式 思路： 先把左子树都进栈，依次出栈，访问左子树，出栈过程把右子树都入栈， 这样访问的顺序就是 左 根 右； 用一个指针p标记当前游标，一个栈保存访问顺序 对于每一个当前节点p，先把左节点全部入栈，在出栈的过程中，依次访问根节点，右子树 栈S; p = root; while(p || S不空){ while(p){ p入S; p = p的左子树; } p = S.top 出栈; 访问p; p = p的右子树; } cpp代码实现 class Solution { public: vector inorderTraversal(TreeNode* root) { if (!root) return {}; vector stk = {}; vector ans; TreeNode* p = root; while (p || !stk.empty()){ while(p){ stk.push_back(p); p = p->left; } p = stk.back(); ans.push_back(p->val); stk.pop_back(); p = p->right; } return ans; } }; Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/binary-tree/深度优先--后序遍历.html":{"url":"chapter/binary-tree/深度优先--后序遍历.html","title":"深度优先--后序遍历","keywords":"","body":"后序遍历 递归思路 var postorderTraversal = function(root) { let ans = [] function dfs(root){ if (!root) return dfs(root.left) dfs(root.right) ans.push(root.val) } dfs(root) return ans }; 非递归思路 先得到根右左，然后逆序得到左右根 得到根右左的过程类似先序得到根左右，先把右子树访问完，把左子树压栈 栈S; p= root; while(p || S不空){ while(p){ 访问p节点； p的左子树入S; p = p的右子树; } p = S栈顶弹出; } 结果序列逆序; 代码实现： class Solution { public: vector postorderTraversal(TreeNode* root) { vector ans; vector stk; TreeNode* p = root; while (p || !stk.empty()){ while(p){ ans.push_back(p->val); stk.push_back(p->left); p = p->right; } p = stk.back(); stk.pop_back(); } reverse(ans.begin(), ans.end()); return ans; } }; Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/binary-tree/广度优先遍历.html":{"url":"chapter/binary-tree/广度优先遍历.html","title":"广度优先遍历","keywords":"","body":"广度优先遍历 也叫 层遍历，BFS 遍历过程是从上到下，一层一层的，更接近人的思维 实现方式 BFS 需要 借助 队列 来实现 应用场景 求解最短、最小路径问题 图的拓扑排序 最短路问题求解（dijkstra算法等） 优点和缺点 优点： 接近人的思维，易于理解 不会爆栈 求最短路 缺点： 代码实现较长 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/binary-tree/二叉搜索树.html":{"url":"chapter/binary-tree/二叉搜索树.html","title":"二叉搜索树","keywords":"","body":"二叉搜索树 二叉搜索树的性质： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 判断条件： 中序遍历是递增序列的二叉树一定是二叉搜索树，可以利用中序遍历是否有序判断是否二叉搜索树 根节点大于所有左子树节点，如果根节点大于左子树的最大值节点即可，因为左子树的最大值位于左子树最右边的节点，所以只要根节点 > 左子树的最右节点即可；同理，根节点 练习题目 530.二叉搜索树的最小绝对差 利用性质：二叉搜索树的中序遍历是递增序列 二叉搜索树中第k小的元素 利用性质：二叉搜索树的中序遍历是递增序列，遍历到第k个元素返回 二叉搜索树中的众数 利用性质：二叉搜索树的中序遍历是递增序列 二叉搜索树的范围和 利用性质：二叉搜索树的中序遍历是递增序列 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/greedy/贪心.html":{"url":"chapter/greedy/贪心.html","title":"贪心","keywords":"","body":"贪心 每次都求最优解，以局部最优得到全局最优 贪心是动态规划的一种特殊类型的题目 概念题 找零钱：有1，2，5三种面值的钞票，每件商品售价3元，输入顾客付款的钞票面额顺序，问能否找零？ 算法思路：优先找较大面值的钱 题目来源 力扣860. 柠檬水找零 区间调度 253.会议室 II 435.无重叠区间 452.用最少数量的箭引爆气球 题目 45.跳跃游戏II 55.跳跃游戏 455.分发饼干 392.判断子序列 376.摆动序列 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/动态规划.html":{"url":"chapter/动态规划.html","title":"动态规划","keywords":"","body":"动态规划 动态规划（Dynamic Programming）是一种分阶段求解策略问题的数学思想。 动态规划中包含三个重要概念：最优子结构、边界、状态转移公式。 最优子结构，求解一个问题时，首先要找出问题的最优子结构； 边界，边界是最简的最优子结构，无需再简化便可得到结果；如果一个问题没有边界，将无法得到有限的结果； 状态转换方程，是阶段与阶段直接的转换关系 动态规划类似于高中数学的数学归纳法 求解过程 确定状态 研究最优策略的最后一步，转化为子问题，定义最优子结构 转换方式 根据子问题定义和最后一步求解过程，抽象出状态转换方程 初始条件和边界情况 细心，考虑周全 计算顺序 利用之前的计算结果 动态规划题目特点 计数 有多少种方式走到右下角 有多少种方法选出k个数使得和为sum 求最值 从左上角走到右下角路径的最大数字和 求最长上升子序列的长度 求存在性 青蛙过河，能否跳到最后一个位置 取石子游戏，先手是否必胜 能不能选出k个数使得和是sum 常见动态规划类型 坐标型动态规划(20%) 重点 序列型动态规划(20%) 重点 划分型动态规划(20%) 重点 区间型动态规划(15%) 重点 背包型动态规划(10%) 双序列型动态规划(5%) 博弈型动态规划(5%) 综合性动态规划(5%) 位操作型动态规划 (了解) 状态压缩DP (了解) 坐标型动态规划 坐标记录状态 可以用滚动数组进行空间优化 硬币组合（一维坐标） 足够的2，5，7面值的硬币，问最少用多少个硬币能组合出面值27（有多少种方式凑出面值27） (力扣518零钱兑换II) f(i) 表示凑出i元所有的最少硬币数（凑出i元的方案数） 不同路径（二维坐标） 机器人从左上角走到右下角，有多少种走法 最小路径和（力扣64） 炸弹袭击(领扣553) 二维矩阵中的格子为空，敌人，墙，炸弹可以放在任意空地上，炸弹会杀死同一行和同一列没有墙阻隔的敌人；问一个炸弹杀死的最大敌人数 最长序列（属于坐标型动态规划） 最长上升子序列(LIS)（力扣300）一维 最长公共子序列(LCS)（力扣1143）二维 序列型动态规划 f[0] 往往表示空序列 有时候会有K维序列，表示K种状态 房子涂色 k种颜色，费用不一样，相邻房子颜色不能相同，求最小花费 打家劫舍（力扣198,213） 六道股票问题 121.买卖股票的最佳时机 122.买卖股票的最佳时机II 123.买卖股票的最佳时机III 188.买卖股票的最佳时机IV 309.最佳买卖股票时机含冷冻期 714.买卖股票的最佳时机含手续费 俄罗斯套娃（力扣354题） O(N^2) 优化成 O(NlogN) TODO 划分型动态规划 给定长度为N的序列，要求划分为若干段 段数不限，或指定K段 每一段满足一定的性质（最小代价，能不能等） 做法： 类似于序列型动态规划，但是通常要加上段数信息 一般用f[i + 1][k]来记录前i个元素（元素0~i-1,f[0][k]表示空序列）分成k段的性质，如最小代价 关注最后一段，枚举最后一段可能情况 + 前面序列, 求最优策略 注意：划分型动态规划每一段序列一定是连续的 数字规律一类题目（一维坐标） 把一个完整的数字分成几个，满足一定的性质 完全平方数（力扣279） 整数拆分（力扣343） 解码方法（力扣91题） 一条包含字母 A-Z 的消息通过以下方式进行了编码：'A' -> 1；'B' -> 2；...；'Z' -> 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 分割回文串(力扣132,1278) 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回符合要求的最少分割次数。（力扣132） 划分型动态规划 修改字符组成k个回文子串的最小修改代价（力扣1278. 分割回文串 III） 划分型动态规划 + k组信息 抄写书籍（领扣437），分割数组的最大值(力扣410) N本书，每本有A[i]页；K个抄写员，每个抄写员可以抄连续的几本书；抄写员抄写速度一样；问最少需要多长时间抄写完毕。 可以用贪心，动态规划更通用，如果稍微变形，贪心就不可以用了 兼职规划找工作（力扣1235），出租车派单（力扣1235拓展） 如果有k个人员(出租车)怎么解？ 区间型动态规划 一般用二维数组表示区间 区间问题只需要考虑 区间头和区间尾 区间型动态规划一般都是hard难度，不过掌握规律，其实也不难 最长回文子序列（力扣516题） 石子游戏（力扣877题） 扰乱字符串（力扣87题） 戳气球(力扣312题) 记忆化搜索跟递推比较 记忆化搜索没法优化，递推可以用滚动数组优化 背包型动态规划 N个物品，有重量数组w,和价值数组v,背包承重为M 求背包能装的最大重量（领扣92） 求背包能装的最大价值(领扣125) 01背包问题，从最大体积向0体积枚举； 完全背包问题，从0体积向最大体积枚举； 一和零 （力扣474） 01背包的变种 双序列型动态规划 最长公共子序列（LCS）（力扣1143题） 应用：比较两篇文章相似程度，前后版本修改等等 交错字符串（力扣97题） 编辑距离（力扣72题） 不同的子序列(力扣115题) 正则表达式匹配（力扣10，44） 博弈型动态规划 博弈型动态规划跟其他类型动态规划不同：博弈型往往从第一步开始分析 石子游戏 （力扣877） 位操作型动态规划 比特位计数(力扣338) 给定N，求0，1，2，...,N每个数的二进制表示中1的个数 状态压缩DP（了解 hard） AcWing 91. 最短Hamilton路径（最短哈密顿距离） 力扣 1349. 参加考试的最大学生数 动态规划求最优解 以01背包为例 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/并查集.html":{"url":"chapter/并查集.html","title":"并查集","keywords":"","body":"概念 并查集(Union-Find Set)，也称为不相交集数据结构（Disjointed Set Data Structure）， 指一系不相交的集合(Sets)，提供合并（Union）和查找(Find)两种操作。 总结：一种用来 解决集合查询合并 的数据结构，支持 近乎O(1)的find操作 和 近乎O(1)的union操作 两个基本操作 find(int i) 判断是否属于同一集合 find(i)即查找I所归属的集合，通常我们使用find(i)和find(j)判断i和j是否连通，即是否属于同一个集合 union(int i , int j) 将两个集合进行合并 顾名思义，union方法即将I和J所在的两个集合连通起来，执行这个方法后，I所在集合和所有元素和J所在集合的所有元素都连通 可以解决的问题（适用场景） 有N个点，用M条线进行两两相连的操作（相连即为合并操作） 问A点和B点是否连通 判断 find(A) == find(B) 问连通块的总个数 for i:0~n; cnt+= i != find(i) 问A点所在连通块的节点个数 for i:0~n; find(A) == find(i) && cnt++ 判断是否存在环路 进行合并操作时，先判断是否连通，如果已经连通，则存在环路，此时进行合并会死循环 代码模板 初始化 for (int i = 0; i 查找find int find(int x) { if (p[x] == x) return x; return p[x] = find(p[x]); // 带路径压缩 } 合并Union 老大哥之间合并，跟小弟没关系 void unionA(int a, int b){ p[find(a)] = find(b); } 完整版代码 int f[N]; for (int i = 0; i 带rank的路径压缩实现（了解） class Solution { public: void makeSet(int n){ vector p(n, 0); for (int i = 0; i rank(n, 0); } int find(vector &p, int x) { if (p[x] != x) { p[x] = find(p, p[x]); //路径压缩 } return p[x]; } void unionSet(vector &p, vector &rank, int x, int y) { x = find(p, x); y = find(p, y); if (rank[x] 练习题目 LeetCode 200. Number of Islands（medium） LeetCode 547. Friend Circles（medium） 基础的并查集 LeetCode 1319. Number of Operations to Make Network Connected (medium) 基础的并查集 765. Couples Holding Hands（hard） 很好的题目，一题多解 [mark] 684. Redundant Connection (Medium) 803. Bricks Falling When Hit(hard) 拓展阅读 算法导论-第21章:用于不想交集合的数据结构 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/树状数组.html":{"url":"chapter/树状数组.html","title":"树状数组","keywords":"","body":"树状数组 区间求和可以使用前缀和去解，时间复杂度O(1) 但是如果元素可变呢？ 树状数组适用于 带更新操作 的 区间和查询 结构 代码实现 单点修改，区间查询 基础版本 由A数组建立C数组 int n = A.size(); vector C(n+1, 0); for (int i = 1; i 单点修改 void add(int x, int k){ for (;x 区间查询[1,x],位置0为空 int ask(int x) { int ans = 0; for (; x >0; x-=x&-x) ans +=t[x]; return ans; } 单点修改：add(x, k); 区间查询：ask(r) - ask(l - 1); 完整版代码 class Solution { public: vector t; int n; void build(vector &nums) { // 建树 n = nums.size(); t = vector(n + 1, 0); for (int i = 1; i 0; x -= x & -x) ans += t[x]; return ans; } }; 树状数组时间复杂度 预处理：O(nlog n) 更新和查询：O(log n) 区间修改，单点查询 使用差分，维护差分数组d[i] = a[i] - a[i - 1]。 区间更新变成了[l, r] 两端l和r的更新，点查询也就变成了[1, x]的区间更新。 区间修改，区间查询 使用差分，维护差分数组d1[i] = a[i] - a[i - 1] 和 d2[i] = i (d2[i] - d2[i - 1])。 区间更新的方式和2相同，区间查询是(r + 1) query(d1, r) - query(d2, r)。通过差分推一推就能得到。 当遇到单点更新时，树状数组往往比线段树更实用 树状数组和线段树比较 树状数组功能比线段树少，实现简单，常数小 树状数组通常只能用于区间求和 线段树能够应用于更多场景，包括：处理区间最大值/最小值等一系列问题 线段树实现较复杂，代码长一些 推荐学习 https://www.bilibili.com/video/av69667943 练习题 lc307.区域和检索 - 数组可修改 poj2352 二维偏序 bzoj1452 bzoj1878 bzoj2743 cf755d Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/位运算.html":{"url":"chapter/位运算.html","title":"位运算","keywords":"","body":"位运算 六种基本运算 与 a & b 或 a | b 取反 ~a 异或 a ^ b 左移 右移 >> 技巧型运算 x & -x lowbits运算: lowbit(x) = x & -x 应用: 得到x的二进制表示中最右边的一个1 推导: 负数 = 正数的补码 + 1 模拟加法 a ^ b相当于 a 与 b 的二进制的不进位相加 配合移位操作可以实现加法操作 模拟乘以2的幂 x 模拟除以2的幂 x >> k 相当于 x / 2的k次幂 比如：我们在使用二分算法时，获取mid，可以 使用 mid = l + (r - l) >> 1 模拟整除判断 (x & m) == 0 相当于 x % (m + 1) == 0 我们常用 x & 1 == 0 来判断 x是否是偶数就是利用此条性质 举例：(x & 3) == 0 相当于 x % 4 == 0 异或运算交换两个元素 a = a ^ b b = a ^ b a = a ^ b 将第k位置为1(k从0开始) x |= (1 将第k位置为0 x &= ~(1 判断第k位是不是1 (x >> i) & 1 或者 x & (1 删除最后一位的1 x & (x-1) x ^ (x & -x) 练习题目 只出现一次的数字 LeetCode 136. Single Number 异或运算求解 LeetCode 137. Single Number II 三进制思路 +状态机 LeetCode 260. Single Number III 低位运算 LeetCode 201. Bitwise AND of Numbers Range LeetCode 231. Power of Two LeetCode 371. Sum of Two Integers LeetCode 405. Convert a Number to Hexadecimal LeetCode 421. Maximum XOR of Two Numbers in an Array LeetCode 476. Number Complement LeetCode 477. Total Hamming Distance LeetCode 762. Prime Number of Set Bits in Binary Representation LeetCode 1009. Complement of Base 10 Integer Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/graph/图.html":{"url":"chapter/graph/图.html","title":"图论","keywords":"","body":"Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/graph/图的遍历.html":{"url":"chapter/graph/图的遍历.html","title":"图的遍历","keywords":"","body":"DFS和BFS DFS和BFS对比 BFS 空间是指数级别的，大 不会有爆栈风险 可以求最短，最小 DFS 空间和深度成正比，小！ 有爆栈的风险，比如深度最坏可能有1e5层，会爆栈（C++一般4M）；层信息都放在栈空间里 不能搜最短、最小 注意事项 判断当前节点、层是否已得到最终解 判断是否可以剪枝 防止循环遍历问题（比如存在环路，要退出） 遍历顺序如何选择（比如是弧头到弧尾还是弧尾到弧头） 题目列表 flood fill算法 LeetCode 733. Flood Fill (easy) flood fill算法, dfs和bfs两种实现 LeetCode 200. Number of Islands（medium） flood fill算法 并查集 LeetCode 111. Minimum Depth of Binary Tree（easy） LeetCode 279. Perfect Squares (medium) LeetCode 130. Surrounded Regions （medium） LeetCode 543. Diameter of Binary Tree LeetCode 127. Word Ladder LeetCode 542. 01 Matrix LeetCode 695. Max Area of Island LeetCode 886. Possible Bipartition（medium） 二分图判定 851. Loud and Rich (medium) 994. Rotting Oranges（easy) LeetCode 980. Unique Paths III (hard) LeetCode 1254. Number of Closed Islands（medium） 拓扑排序相关 拓扑排序，将AOV网转化成线性序列 应用场景：判断一个图中有没有环 & 图中每一个点是否在环里； LeetCode 207. Course Schedule LeetCode 210. Course Schedule II LeetCode 802. Find Eventual Safe States (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/graph/拓扑排序.html":{"url":"chapter/graph/拓扑排序.html","title":"拓扑排序","keywords":"","body":"拓扑排序 应用场景 拓扑排序的一个重要应用：判断AOV网中是否存在环。对有向图构造拓扑排序，如果所有顶点都在它的拓扑序列中，则该AOV网必定不存在环。 算法过程 在图中找到一个入度为0的点，加入到维护的结果队列 对图进行拆点操作，拆掉这个点和所有相连的边 重复上面的两步，所有点都已拆除（拓扑序列中已经包含所有点） 拓扑排序实际上是BFS的一种特殊情况，每次加入队列的点是入度为0的点，加入队列后拆掉相邻的边；记录已经拆掉的点 练习题目 lc207. 课程表 顶点表示课程，弧表示课程间的制约关系，AOV网的应用。 lc210. 课程表 II lc802. 找到最终的安全状态 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/graph/朴素的Dijkstra算法.html":{"url":"chapter/graph/朴素的Dijkstra算法.html","title":"朴素的Dijkstra算法","keywords":"","body":"朴素的Dijkstra算法 集合S：当前已经确定最短距离的点 dist[1] = 0, dist[i] = 正无穷 for v: 1 ~ n t 朴素的Dijkstra算法往往是稠密图，用邻接矩阵来存储 算法模板 int g[N][N]; // 存储每条边；为稠密阵所以用邻接矩阵存储 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); //初始化距离 0x3f代表无限大 dist[1] = 0; //第一个点到自身的距离为0 for (int i = 0; i dist[j])) t = j; st[t] = true; // t号点的最短路已经确定 // 用t更新其他点的距离 for (int j = 1; j 时间复杂是 O(n2+m), n 表示点数，m 表示边数 题目 AcWing849. Dijkstra求最短路 I lc743. 网络延迟时间 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/graph/二分图.html":{"url":"chapter/graph/二分图.html","title":"二分图","keywords":"","body":"二分图 一个图是二分图，当且仅当图中不含有奇数环 反之，如果图中不含有奇数环，则一定是二分图 染色法 染色法是判断二分图最常用的方法，当且仅当所有节点被染色，且没有冲突发生，证明该图是二分图 题目 LeetCode 785. Is Graph Bipartite? (medium） LeetCode 886. Possible Bipartition（medium） Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/math/数论.html":{"url":"chapter/math/数论.html","title":"数论","keywords":"","body":"数学知识 质数 约数 欧拉函数 快速幂 扩展欧几里得算法 中国剩余定理（CRT) 高斯消元 组合计数 容斥原理 简单博弈论 拓展： 费马小定理 欧拉定理 欧拉降幂公式 威尔逊定理 扩展CRT 质数 试除法判定质数 bool is_prime(int x) { if (x 时间复杂度 O(根号n) AcWing 866. 试除法判定质数 试除法分解质因数 void divide(int x){ for (int i = 2; i 1) printf(\"%d %d\\n\", x, 1); // 输出 剩下的最后一个质因子 } AcWing 867. 分解质因数 筛质数 bool st[N]; // 是否被筛掉； true: 不是质数，被筛掉了 int primes[N], cnt = 0; // primes[]存储所有素数; cnt：当前下标 //朴素筛法-O(nlogn) void get_primes(int x) { for(int i = 2; i AcWing 868. 筛质数 lc204. 计数质数 约数 试除法求约数 vector get_divisors(int x) { vector res; for (int i = 1; i 约数个数 和 约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck // pi为质因子，ci为质因子的幂 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) // 每个质因子有 ci + 1种取法（取0~ci次） 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) // 直接因式分解证明 最大公约数 欧几里得算法 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 欧拉函数 欧拉函数可以用容斥原理证明 快速幂 求 a 的 k 次方 mod p的结果 (1 原理：平方取模，把k进行二进制拆解，二进制移位运算 时间复杂度 O(logK) int qmi(int a, int k, int p){ LL res = 1; while (k){ if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } 扩展欧几里得算法 裴（pei）蜀定理 对于任意一对正整数a,b,一定存在x,y, 使得 ax + by = (a, b) (a, b)表示 gcd(a,b)的倍数 => ax + by 能凑出的最小正整数 就是 gcd(a, b) 扩展欧几里得算法 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int &x, int &y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 应用: 求解线性同余方程 练习: Leetcode 365. 水壶问题 中国剩余定理 高斯消元 组合计数 容斥原理 简单博弈论 容斥原理 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"chapter/math/抽屉原理.html":{"url":"chapter/math/抽屉原理.html","title":"抽屉原理","keywords":"","body":"抽屉原理 练习题目 剑指offer13. 找出数组中重复的数字 lc442. 数组中重复的数据 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-11 00:10:24 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-07 09:08:52 "}}