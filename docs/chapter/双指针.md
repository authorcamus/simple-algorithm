# 双指针问题

双指针是这样的模式：两个指针朝着左右方向移动（双指针分为同向双指针和异向双指针），直到他们有一个或是两个都满足某种条件。双指针通常用在排好序的数组或是链表中寻找对子。比如，你需要去比较数组中每个元素和其他元素的关系时，你就需要用到双指针了。

我们需要双指针的原因是：如果你只用一个指针的话，你得来回跑才能在数组中找到你需要的答案。这一个指针来来回回的过程就很耗时和浪费空间了 — 这是考虑算法的复杂度分析的时候的重要概念

在很多情况下，双指针能帮助我们找到空间或是时间复杂度更低的解。

识别使用双指针的招数：

- 一般来说，数组或是链表是排好序的，你得在里头找一些组合满足某种限制条件
- 这种组合可能是一对数，三个数，或是一个子数组

## 两数和

题目：两数和--两个数的差等于目标值

### 朴素做法

枚举一个右端点，枚举一个左端点，求差

时间复杂度O(N^2)

### 假定已经排好序

#### 二分查找

当枚举一个右端点时，问题变为：找到一个左端点，使得nums[r]-nums[l] = target;
排好序后，右端点和左端点的差具有单调性，可以用二分找左端点；
时间复杂度：对于每个右节点，进行一次二分找左端点 N*log(N)

#### 双指针移动

两个指针同时向右移动

主动指针R,被动指针L

```cpp
l = 0
for(r = 0; r < n; r++){
    while(A[r]-A[l] > target){
        l++
    }
    if (A[r]-A[l] == target) ans.push_back({l, r})
}
```

主动指针L,被动指针r

```cpp
r = 0
for (l = 0; l < n-1; l++){
    while (A[r] - A[l] < target && r < n) r++
    if (A[r]-A[l] == target) ans.push_back({l, r})
}
```

时间复杂度 O(NlogN)

一般用用右指针作为主动指针，左指针作为被动指针，如果左指针作为主动指针，需要判断右指针是否越界

### 哈希

时间复杂度 O(N),空间复杂度O(N)

## 题目：和大于S的最小子数组

给定一个由 n 个正整数组成的数组和一个正整数 s ，请找出该数组中满足其和 ≥ s 的最小长度子数组。如果无解，则返回 -1。

```cpp
样例 1:

输入: [2,3,1,2,4,3], s = 7
输出: 2
解释: 子数组 [4,3] 是该条件下的最小长度子数组。
```

### 朴素算法

枚举左端点，枚举右端点，求区间和

时间复杂度O(N^3)

### 前缀和数组

前缀和数组：dp[i]表示数组A所有区间元素[0,i-1]的和

枚举一个左端点，枚举一个右端点，用前缀和数组求和

时间复杂度O(N^2)

### 前缀和+二分法优化

题目中所有元素都为正整数，所以前缀和具有单调性

枚举一个右端点，找左端点的位置，用二分查找优化

时间复杂度O(NlogN)

### 双指针+前缀和

双指针表示区间位置，前缀和求区间和

时间复杂度O(N)

```cpp
class Solution {
public:
    int minimumSize(vector<int> &nums, int s) {
        vector<int> pre(nums.size()+1, 0);
        for (int i = 1; i<= nums.size(); i++){
            pre[i] = nums[i-1] + pre[i-1];
        }
        int ans = 1<< 31 -1;
        int r = 1;
        for (int l = 0; l < nums.size(); l++){
            while (r <= nums.size() && pre[r] - pre[l] < s) {
                r++;
            }
            if (r <= nums.size() && pre[r] - pre[l] >= s) {
                ans = min(ans, r -l);
            }
        }
        return ans == 1<< 31 -1 ? -1: ans;
    }
};
```

### 双指针；滑动窗口

两个指针L，R，一个主动指针，一个被动指针，同时向右移动

```cpp
class Solution {
public:
    int minimumSize(vector<int> &nums, int s) {
        int ans = 1<< 31 -1;
        int sum = 0;
        int l = 0, r =0;
        while (r < nums.size()){
            sum+=nums[r];
            r++;
            while (l < r && sum >=s){
                ans = min(ans, r - l);
                sum-=nums[l];
                l++;
            }
        }
        return ans == 1<< 31 -1 ? -1: ans;
    }
};
```

## 题目：两数和 II-输入已排序的数组

给定一个已经 按升序排列 的数组，找到两个数使他们加起来的和等于特定数。
函数应该返回这两个数的下标，index1必须小于index2。注意返回的值不是 0-based。

---

两个指针相向移动

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        for (int l = 0, r = nums.size()-1; r >0; r--){
            while (nums[l] + nums[r] < target){
                l++;
            }
            if (nums[l] + nums[r] == target) return {l+1, r+1};
        }
        return {};
    }
};
```


## 求解最大跨度

算法思路：

以求解递增序列最大跨度为例

1. 定义单减栈，保存从左到右出现的最小值的下标
2. 从右到左遍历，当元素大于栈顶元素，出栈，更新最大跨度max；直到栈为空或移动到下标为max的位置，不需要再向左移动；

### 题目

- [LeetCode 962. Maximum Width Ramp (medium)](https://github.com/muyids/leetcode/blob/master/algorithms/901-1000/962.maximum-width-ramp.md)

- [LeetCode 1124. Longest Well-Performing Interval (medium)](https://github.com/muyids/leetcode/blob/master/algorithms/1101-1200/1124.longest-well-performing-interval.md)

