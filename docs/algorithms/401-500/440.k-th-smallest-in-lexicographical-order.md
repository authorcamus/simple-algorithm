给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

```cpp
示例 :

输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

---

## 算法思路

- 画出字典树
- k表示要找到后面的第k个元素，起始下标是0
- 获取以prefix开头的数字个数，包括他本身
  - 如果数字个数大于k，下移，在prefix*10下的子树进行查找 
  - 如果数字个数小于等于k，右移，在prefix+1下的子树进行查找

问题的关键是求解 以prefix开头的数字个数，包括他本身

- 根节点 `[prefix, prefix+1 )`
- 第一层 `[prefix*10, (prefix+1)*10 )`
- 第二层 `[prefix*100, min(n+1, (prefix+1)*100) )`
- ...


## 代码实现

```cpp
class Solution {
public:
typedef long long LL;
    int findKthNumber(int n, int k) {
        int prefix = 1;
        k--; // k记录要找的数字在prefix后的第几个
        while (k>0){
            int cnt = getCnt(n, prefix); // 当前prefix 下有多少个元素;包含prefix
            if (cnt <= k) { // 向右
                k -= cnt;
                prefix++;
            } else { // 向下
                k--;
                prefix*=10;
            }
        }
        return prefix;
    }
    int getCnt(LL n, LL prefix){
        LL cnt = 0;
        for (LL first = prefix, second = prefix+1; first<=n; first*=10, second*=10){
            cnt+= min(n + 1, second) - first;
        }
        return cnt;
    }
};
```

