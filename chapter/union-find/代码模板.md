## 代码模板

初始化

```cpp
for (int i = 0; i< n ; i++) p[i] = i;
```

### 查找find

```cpp
int find(int x) {
    if (p[x] == x) return x;
    return p[x] = find(p[x]); // 带路径压缩
}
```

### 合并Union

> 老大哥之间合并，跟小弟没关系

```cpp
void unionA(int a, int b){
    p[find(a)] = find(b);
}
```

### 完整版代码

```cpp
int f[N];

for (int i = 0; i < n; i++)f[i] = i; // 构造

int find(int x) { // 查询
    if (f[x] == x) return x;
    return f[x] = find(f[x]);
}

void u(int x, int y) { // 合并; 当find(x) != find(y) 才进行合并； 如果find(x) == find(y)，没必要进行合并，已经在一个集合；此时进行合并表明存在环路；
    f[find(x)] = find(y);
}

bool isOneSet(int x, int y) return find(x)==find(y);
```

## 带rank的路径压缩实现（了解）

```cpp
class Solution {
public:
    void makeSet(int n){
        vector<int> p(n, 0);
        for (int i = 0; i < n; i++) {
            p[i] = i;
        }
        vector<int> rank(n, 0);
    }

    int find(vector<int> &p, int x) {
        if (p[x] != x) {
            p[x] = find(p, p[x]);  //路径压缩
        }
        return p[x];
    }

    void unionSet(vector<int> &p, vector<int> &rank, int x, int y) {
        x = find(p, x);
        y = find(p, y);
        if (rank[x] < rank[y]) p[x]= y;
        else {
            p[y] = x;
            if (rank[x] == rank[y]) rank[x]++;
        }
    }
};
```
