## 单调栈

单调栈分为单调递增栈和单调递减栈

单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈

单调栈里存的是数组元素的值或下标

单调栈的意义：可以在O(N)的时间复杂度，找到两边第一个小于或大于当前元素的值；

常见模型：找出每个数左右两边离它最近（或第一个）大于或小于它的解

单调递增栈用于查找两边第一个小于当前元素的值，单调递减栈用于查找两边第一个大于当前元素的值

一般数组中的单调性问题，题目中隐含第一个或离此元素最近的大于或小于元素的值，这类问题都可以考虑下，用单调栈是否可以求解

动画演示

![单调栈动画演示](https://raw.githubusercontent.com/muyids/tuchuang/master/monotone-stack.gif)

单调递增栈模板

```cpp
stack<int> stk;
for (int i = 0; i < A.size(); i++) {
    while (stk.size() && A[i] <= A[stk.top()]) {
        stk.pop();
    }
    stk.push(i);
}
```

## 例题

给定一个长度为N的正整数数组，输出每个数左右两边第一个比它小的数，如果不存在则输出-1。

```cpp
输入: [3,4,2,7,5]

输出：
左边：[-1, 3, -1, 2, 2]
右边：[2, 2, -1, 5, -1]
```

单调递增栈

- 出栈时，栈顶右边第一个更小的 元素是即将入栈的当前元素
- 入栈时，当前元素 左边的第一个更小的元素 是 栈顶元素

```cpp
void sumSubarrayMins(vector<int> &A) {
    int n = A.size();
    vector<int> lmin(n, -1);
    vector<int> rmin(n, -1);
    stack<int> stk; // 单调递增栈
    for (int i = 0; i < A.size(); i++) {
        while (stk.size() && A[i] <= A[stk.top()]) {
            rmin[stk.top()] = A[i];
            stk.pop();
        }
        if (stk.size()) lmin[i] = A[stk.top()];
        stk.push(i);
    }
}
```

时间复杂度O(N)，空间复杂度O(N)

拓展练习

- lc907. 子数组的最小值之和

## 练习题目

### lc42. 接雨水

### lc84. 柱状图中最大的矩形

单调递增栈

### lc85. 最大矩形

在84题基础上可以求解

### lc239. 滑动窗口最大值

### lc402. 移掉K位数字

贪心 + 单调递增栈，也是一道有趣的题目

### lc503. 下一个更大元素 II

求右边大于元素的最近的元素；单调递减栈 + 循环队列

## lc768. 最多能完成排序的块 II

特殊的单调递增栈，存储元素为两个边界

### lc739. 每日温度

### lc901. 股票价格跨度

求大于元素的左边第一个元素和右边第一个元素的跨度

### lc962.最大宽度坡

单调栈求整个序列最大跨度问题

跟1124类似

### 1019.链表中的下一个更大节点

求大于元素的右边最近的元素

### lc1124. 表现良好的最长时间段

前缀和 + 单调栈

单调栈求整个序列最大跨度问题
