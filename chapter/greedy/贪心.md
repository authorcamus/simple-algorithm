# 贪心

每次都求最优解，以局部最优得到全局最优

贪心是动态规划的一种特殊类型的题目

## 概念题

找零钱：有1，2，5三种面值的钞票，每件商品售价3元，输入顾客付款的钞票面额顺序，问能否找零？

算法思路：优先找较大面值的钱

题目来源 **力扣860. 柠檬水找零**

## 常见问题

### [区间问题](./区间问题.md)

[区间问题](./区间问题.md)

### 跳跃游戏

- [LeetCode 55. Jump Game (medium)](https://github.com/muyids/leetcode/blob/master/algorithms/1-100/55.jump-game.md)

- [LeetCode 45. Jump Game II (hard)](https://github.com/muyids/leetcode/blob/master/algorithms/1-100/45.jump-game-ii.md)

- [LeetCode 1306. Jump Game III (medium)](https://github.com/muyids/leetcode/blob/master/algorithms/1301-1400/1306.jump-game-iii.md)

- [LeetCode 1345. Jump Game IV (hard)](https://github.com/muyids/leetcode/blob/master/algorithms/1301-1400/1345.jump-game-iv.md)

- [LeetCode 1340. Jump Game V (hard)](https://github.com/muyids/leetcode/blob/master/algorithms/1301-1400/1340.jump-game-v.md)

### 具有单调性的集合选择

- [LeetCode 857. Minimum Cost to Hire K Workers (hard)](https://github.com/muyids/leetcode/blob/master/algorithms/801-900/857.minimum-cost-to-hire-k-workers.md)


- 180场周赛  最大的团队表现值  TODO

### 最大的团队表现值

#### 贪心

- 将所有工人按效率从大到小排序
- 优先队列 S集合 维护K个工人组成组成的 表现最好的团队，优先队列按速度从小到大排序
- 枚举 所有工人
  - 当S集合元素数量小于K时，直接加入集合
  - 当S集合元素数量大于等于K时，比较当前工人和S集合堆顶的工人的速度大小
    - 如果当前工人较慢，直接pass
    - 如果当前工人较快，计算堆顶替换成当前工人，是否能够获得更好的表现

#### 时间复杂度

对所有工人排序 O(nlogn)

枚举每个工人，与堆顶比较 O(nlogK)

总体时间复杂度 O(nlogn)

#### C++ 代码

```cpp
bool cmp(vector<int> &n1, vector<int> &n2){
    return n1[1] > n2[1];
}

class Solution {
public:
    const int mod = 1e9 + 7;
    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {
        vector<vector<int>> workers;
        for (int i =0; i<n; i++){
            workers.push_back({speed[i], efficiency[i]});
        }
        sort(workers.begin(), workers.end(), cmp);

        long long sum = 0;
        long long ans = 0;
        priority_queue<int, vector<int>, greater<int>> q;
        for (auto &w: workers){
            if (q.size() <k){
                q.push(w[0]);
                sum += w[0]; 
            } else {
                if (w[0] <= q.top()) continue;
                sum = sum - q.top() + w[0];
                q.pop();
                q.push(w[0]);
            }
            ans = max(ans, sum * w[1]);
        }
        return ans % mod;
    }
};
```

### 其他问题

- [LeetCode 455. Assign Cookies (easy)](https://github.com/muyids/leetcode/blob/master/algorithms/401-500/455.assign-cookies.md)

- [LeetCode 392. Is Subsequence (easy)](https://github.com/muyids/leetcode/blob/master/algorithms/301-400/392.is-subsequence.md)

- [LeetCode 376. Wiggle Subsequence (medium)](https://github.com/muyids/leetcode/blob/master/algorithms/301-400/376.wiggle-subsequence.md)
