
# 博弈型动态规划

博弈型动态规划跟其他类型动态规划不同：博弈型往往从第一步开始分析

## 石子游戏

一个数字序列，两名玩家，两人依次从左右两个端点取，两人都会做出最佳选择

输出第一位玩家是否会取的胜利

题目来源： 力扣877.石子游戏，力扣486.预测赢家

题目拓展：如果变成3名玩家，该如何求解哪一位玩家会取胜？

### 动态规划

最优子结构

dp[i][j]表示区间[i, j]先手比后手可以多得的分数

状态转换

- 如果区间长度为1，即`i==j`时，`dp[i][j] = dp[i][i] = nums[i]`
- 如果区间长度大于等于2，即`j-i>=1`,先手可以选择从头部选择或者从尾部选择，如果是从头部选择`dp[i][j] = nums[i] - dp[i+1][j]`,如果是从尾部选择`dp[i][j] = nums[j] - dp[i][j-1]`
- 得到`dp[i][j] = Math.max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])`

返回结果

dp[0][n-1] 是否大于等于 0

### 代码实现

```cpp
class Solution {
public:
    bool PredictTheWinner(vector<int>& nums) {
        int n = nums.size();

        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = 0; i< n; i++) dp[i][i] = nums[i];
        for (int len = 2; len <=n; len++){
            for (int i = 0; i + len  <= n; i++){
                int j = i+len -1;
                dp[i][j] = max(nums[i] - dp[i+1][j], nums[j]-dp[i][j-1]);
            }
        }

        return dp[0][n-1] >= 0;
    }
};
```

