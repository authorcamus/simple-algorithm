
# 快排

快排的思想：递归+分治

- 选择一个轴（pivot），下标i, j,通过不断移动下标、比较、交换，使得轴左边所有数据小于轴，右边所有数据大于轴；
- 递归进行上述过程，直到所有数列长度为0或1，排序结束；
- 由于每次迭代过程，至少有一个值（轴）排好序，所以最终算法会终止；

```javascript
function quickSort(nums) {

    function recursive(nums, i, j) {
        if (i >= j) return nums
        let pivot = partition(nums, i, j)
        recursive(nums, i, pivot - 1)
        recursive(nums, pivot + 1, j)
        return nums
    }

    function partition(nums, low, high) {
        let pivot = nums[low]
        while (low < high) {
            while (low < high && nums[high] >= pivot) high--
            nums[low] = nums[high]
            while (low < high && nums[low] < pivot) low++
            nums[high] = nums[low]
        }
        nums[low] = pivot
        return low
    }

    return recursive(nums, 0, nums.length - 1)
}
```

不稳定排序，中间交换过程会打乱顺序

时间复杂度：最差O(N^2)，平均O(N^logN)

---

优化

- 随机轴元素

---

另一种写法(轴的位置可以随机)：

1. 取中点为轴
2. 找到左边第一个大于等于轴的元素A，找到右边第一个大于等于轴的元素B
3. 当A的下标小于B的下标时，交换
4. 递归上述过程

```cpp
void quick_sort(int q[], int l, int r) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j) {
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

## 题目

### Top-K问题

### [LeetCode215.Kth Largest Element in an Array](https://github.com/muyids/leetcode/blob/master/algorithms/201-300/215.kth-largest-element-in-an-array.md) (medium)
